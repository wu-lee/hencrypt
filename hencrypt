#!/bin/bash

# Author: Nick Stokoe
#
# https://github.com/wu-lee/hencrypt
#
# For usage, execute with no parameters, or see the `usage` function
# below.

set -o pipefail
set -o errexit

# Defaults

# See https://www.keylength.com/en/compare/
# 4096 RSA/256 AES should be good for a few decades.
# Note CYPHEROPT correlates with ONETIMEKEYSIZE.
RSAKEYSIZE=4096
ONETIMEKEYSIZE=256
OPENSSL=/usr/bin/openssl
BASE64=/usr/bin/base64
CYPHEROPT=-aes-256-cbc

# Write to stderr
function warn() {
    printf "%s\n" "$*" >&2
}

# Exit with a nonzero code, printing the arguments on stderr
function die() {
    warn "exiting: $*" >&2
    exit 1
}

# We use this to avoid the use of `cat`.  Works much the same,
# except it optionally omits lines matching a regex
function copyout() {
    while IFS='' read -r line; do
	[[ -n "$1" && "$line" =~ $1 ]] || printf "%s\n" "$line"
    done
}

# Versioning 
VERSION=0.1.0
OPENSSL_VERSION=$("$OPENSSL" version) || die "Failed to get openssl version"
BASE64_VERSION=$("$BASE64" --version) || die "Failed to get base64 version"

# Generates an ASCII-armoured RSA keypair to stdout
function genkeys() {
    local keyfile=${1?you must supply a key filename}
    warn "Writing keypair to $keyfile:"
    "$OPENSSL" genrsa "$RSAKEYSIZE"  >$keyfile
    warn "Copying public key to $keyfile.pub:"
    "$OPENSSL" rsa -pubout <$keyfile >$keyfile.pub
}

# Generates a random key, in base64.
# Output is on stdout and the significant data on the first line to work correctly.
# A dummy linefeed is appended so that `read` will not return an error code
# because of EOF.
function genonetime() {
    "$OPENSSL" rand  "$ONETIMEKEYSIZE" | "$BASE64" -w0 &&
    printf "\n"
}

# rsaencrypt $pubkeyfile
#
# RSA encrypts a base64 encoded stream to a base64 stream on stdout,
# using the public keyfile given.
#
# Output is on stdout and the significant data on the first line to work correctly.
# A dummy linefeed is appended so that `read` will not return an error code
# because of EOF.
function rsaencrypt() {
    local pubkeyfile
    pubkeyfile=${1?you must supply a public key file} &&
    "$BASE64" -d | "$OPENSSL" rsautl -encrypt -pubin -inkey "$pubkeyfile" | "$BASE64" -w0 &&
    printf "\n"
}

# rsadecrypt $privkeyfile
#
# RSA decrypts a base64 encoded stream to a base64 stream on stdout,
# using the private keyfile given.
#
# Output is on stdout and the significant data on the first line to work correctly.
# A dummy linefeed is appended on success so that `read` will not return an error code
# because of EOF.
function rsadecrypt() {
    local privkeyfile
    privkeyfile=${1?you must supply a private key file} &&
    "$BASE64" -d | "$OPENSSL" rsautl -decrypt -inkey "$privkeyfile" | "$BASE64" -w0 &&
    printf "\n"
}

# encrypt $keyfile - Hybrid-encrypts stdin to stdout.
#
# A one-time key is generated, encrypted using the public RSA key,
# and then written out base64-encoded as the first line.
# Then the standard input is encrypted as the rest of the stream, in binary format.
function encrypt() {
    local onetimekey eonetimekey
    local pubkeyfile=${1?you must supply a public key file}
    [ -f "$pubkeyfile" ] || die "no such file: $pubkeyfile"

    # Generate a random one-time key for symmetric encryption
    # Avoid exposing the value via shell-expansion, use read.
    read -r onetimekey < <(genonetime) || die "genonetime failed"

    # Encrypt it with asymmetric RSA encryption.
    # Use a herestring to avoid putting onetimekey in a file or the arglist
    # However, we don't care so much once it is encrypted.
    eonetimekey=$(rsaencrypt "$pubkeyfile" <<<"$onetimekey") || die "rsaencrypt failed"

    # 4096 bits is a very strong RSA key length. Encoded in base64
    # this takes 682 characters. 9999 characters should therefore be
    # more than adequate for any conceivable RSA strength we could
    # ever use.
    [[ ${#eonetimekey} > 9999 ]] && die "unsupported: encrypted one-time keys larger that 9999 chars of base64"
    
    # Print the encrypted key and its length (in chars) first. We use a length to avoid
    # permitting an arbitrarily long read on decryption.
    printf "%04d%s" "${#eonetimekey}" "$eonetimekey"

    # Encrypt stdin -> stdout using our one-time key, which is read from stderr
    # (actually openssl treats it as a password, so we can use base64)
    "$OPENSSL" enc $CYPHEROPT -salt -pass fd:2 2<<<"$onetimekey"
}

# decrypt $keyfile -  Hybrid-decrypts stdin to stdout.
#
# The first line is expected to be a
# base64 encoded, RSA encrypted symmetric cypher key.  This is read,
# decrypted using the private key file supplied, used to decrypt the rest of the
# binary stream on stdin.
function decrypt() {
    local privkeyfile=${1?you must supply a private key file}
    [ -f "$privkeyfile" ] || die "no such file: $privkeyfile"

    # Read our RSA encrypted base64 encoded one time key from the
    # first line of stdin.
    local eonetimekey
    read -N 4 length
    [[ "$length" =~ [0-9]{4} ]] || die "invalid length field encountered whilst decrypting"
    read -N "$length" eonetimekey || die "EOF reading encrypted one-time key"

    # Decrypt it.  Use a herestring to avoid putting onetimekey in a
    # file or the arglist. Avoid exposing the value via
    # shell-expansion, use read.
    local onetimekey
    read -r onetimekey < <(rsadecrypt "$privkeyfile" <<<"$eonetimekey") || die "rsadecrypt failed"

    # Decrypt the rest of the stream with it
    # (actually openssl treats it as a password, so we can use base64)
    "$OPENSSL" enc -d $CYPHEROPT -pass fd:2 2<<<"$onetimekey" || die "failed to decrypt"
}


# Just prints usage to stderr
usage() {
    # Avoiding the use of external commands like cat, basename. 
    copyout <<'USAGE' >&2;

hencrypt - Hybrid encryption of potentially large datastreams.


USAGE:

    hencrypt -h 

Prints this usage.


    hencrypt [-S] -g <keyfile>

Generates a new RSA keypair in <keyfile> and copies the public portion
to <keyfile>.pub. Use the former for decryption, and the latter for
encryption.


    hencrypt [-s] -e <keyfile.pub>

Encrypts stdin to stdout using the supplied public key file


    hencrypt -d <keyfile>

Decrypts stdin to stdout, using the supplied private key file (may
also be a keypair file).


The following options can be supplied in some cases (as indicated),
and are ignored otherwise:

 - `-s` - sets the one-time key size (in bits).  Default: 256

 - `-S` - sets the RSA key size (in bits).  Default: 4096


    hencrypt -v

Prints out version information.


USAGE
}


while getopts "hedgvs:S:" OPTION
do
    case "$OPTION" in
        h|d|e|g|v)
	    [[ -z "$operation" ]] || die "can only use one of -e -d or -g"
	    operation=$OPTION
            ;;

	s)
	    [[ "$OPTARG" -gt 0 ]] || die "one-time key size must be numeric and positive"
	    ONETIMEKEYSIZE=$OPTARG
	    ;;
	
	S)
	    [[ "$OPTARG" -gt 0 ]] || die "RSA key size must be numeric and positive"
	    RSAKEYSIZE=$OPTARG
	    ;;
	
        *)
            usage
	    exit 1
            ;;
    esac
done

# remove the options from the argument list
shift $((OPTIND-1))

if [[ "$operation" == "h" ]]; then
    usage
    exit 0
fi

if [[ "$operation" == "v" ]]; then
    copyout <<EOF

VERSIONS

hencrypt:
VERSION: $VERSION
CYPHEROPT: $CYPHEROPT
RSAKEYSIZE: $RSAKEYSIZE
ONETIMEKEYSIZE: $ONETIMEKEYSIZE

openssl:
$($OPENSSL version -a)

base64:
$($BASE64 --version)

EOF
    exit 0
fi


# Validate the remaining options
if [[ $# != 1 ]]; then
    usage
    die "you must supply a key file as the only argument"
fi

# Execute the appropriate action
case "$operation" in
    d) decrypt "$1"; exit;;
    e) encrypt "$1"; exit;;
    g) genkeys "$1"; exit;;
esac

die "you must supply one of the options d, e, g or h."
